using System.Collections.Generic;
using Godot;
using NullAndVoid.Combat;

namespace NullAndVoid.Effects;

/// <summary>
/// Style of projectile animation.
/// </summary>
public enum ProjectileAnimStyle
{
    /// <summary>Instant hit, no travel time (hitscan).</summary>
    Instant,

    /// <summary>Fast traveling bullet.</summary>
    Bullet,

    /// <summary>Instant beam line that fades.</summary>
    Beam,

    /// <summary>Medium speed glowing plasma bolt.</summary>
    Plasma,

    /// <summary>Curved arc path (grenades, thrown).</summary>
    Lobbed,

    /// <summary>Jumping electrical arc between points.</summary>
    Chain
}

/// <summary>
/// Visual representation of a projectile traveling from attacker to target.
/// Handles animation timing and spawns trail particles.
/// </summary>
public class ProjectileVisual
{
    /// <summary>
    /// Starting position (attacker).
    /// </summary>
    public Vector2I Start { get; }

    /// <summary>
    /// Ending position (target).
    /// </summary>
    public Vector2I End { get; }

    /// <summary>
    /// Total animation duration in seconds.
    /// </summary>
    public float Duration { get; }

    /// <summary>
    /// Current animation time.
    /// </summary>
    public float Timer { get; private set; }

    /// <summary>
    /// Display character for the projectile.
    /// </summary>
    public char Character { get; set; }

    /// <summary>
    /// Character sequence for animated projectiles.
    /// </summary>
    public char[]? CharacterSequence { get; set; }

    /// <summary>
    /// Current character animation index.
    /// </summary>
    private int _characterIndex;

    /// <summary>
    /// Time until next character change.
    /// </summary>
    private float _characterTimer;

    /// <summary>
    /// Interval between character changes.
    /// </summary>
    public float CharacterInterval { get; set; } = 0.05f;

    /// <summary>
    /// Projectile color.
    /// </summary>
    public Color Color { get; set; }

    /// <summary>
    /// Trail color (for fading trail).
    /// </summary>
    public Color TrailColor { get; set; }

    /// <summary>
    /// Animation style.
    /// </summary>
    public ProjectileAnimStyle Style { get; }

    /// <summary>
    /// Whether to spawn trail particles.
    /// </summary>
    public bool SpawnTrail { get; set; } = true;

    /// <summary>
    /// Density of trail particles (0-1).
    /// </summary>
    public float TrailDensity { get; set; } = 0.5f;

    /// <summary>
    /// Trail particle lifetime.
    /// </summary>
    public float TrailLifetime { get; set; } = 0.15f;

    /// <summary>
    /// Last position where trail was spawned.
    /// </summary>
    private Vector2I _lastTrailPos;

    /// <summary>
    /// Arc height for lobbed projectiles (tiles).
    /// </summary>
    public float ArcHeight { get; set; } = 2f;

    /// <summary>
    /// Current interpolated position.
    /// </summary>
    public Vector2 CurrentPosition
    {
        get
        {
            float t = Duration > 0 ? Timer / Duration : 1f;
            var basePos = Vector2.Zero;
            basePos.X = Mathf.Lerp(Start.X, End.X, t);
            basePos.Y = Mathf.Lerp(Start.Y, End.Y, t);

            // Add arc for lobbed projectiles
            if (Style == ProjectileAnimStyle.Lobbed && ArcHeight > 0)
            {
                float arcProgress = Mathf.Sin(t * Mathf.Pi);
                basePos.Y -= arcProgress * ArcHeight;
            }

            return basePos;
        }
    }

    /// <summary>
    /// Current grid position (rounded).
    /// </summary>
    public Vector2I GridPosition => new((int)Mathf.Round(CurrentPosition.X), (int)Mathf.Round(CurrentPosition.Y));

    /// <summary>
    /// Animation progress (0-1).
    /// </summary>
    public float Progress => Duration > 0 ? Mathf.Clamp(Timer / Duration, 0, 1) : 1f;

    /// <summary>
    /// Whether the animation is complete.
    /// </summary>
    public bool IsComplete => Timer >= Duration;

    /// <summary>
    /// Current display character.
    /// </summary>
    public char CurrentCharacter
    {
        get
        {
            if (CharacterSequence != null && CharacterSequence.Length > 0)
            {
                return CharacterSequence[_characterIndex % CharacterSequence.Length];
            }
            return Character;
        }
    }

    /// <summary>
    /// Particles generated by this projectile's trail.
    /// </summary>
    public List<Particle> TrailParticles { get; } = new();

    public ProjectileVisual(Vector2I start, Vector2I end, ProjectileAnimStyle style, float speed)
    {
        Start = start;
        End = end;
        Style = style;

        // Calculate duration based on distance and speed
        float distance = (end - start).Length();

        Duration = style switch
        {
            ProjectileAnimStyle.Instant => 0f,
            ProjectileAnimStyle.Beam => 0.15f,  // Brief flash
            ProjectileAnimStyle.Bullet => distance / speed,  // tiles per second
            ProjectileAnimStyle.Plasma => distance / (speed * 0.6f),  // Slower than bullets
            ProjectileAnimStyle.Lobbed => distance / (speed * 0.4f) + 0.3f,  // Even slower with hang time
            ProjectileAnimStyle.Chain => 0.1f,  // Quick jump per segment
            _ => distance / speed
        };

        Timer = 0;
        _lastTrailPos = start;
        _characterTimer = CharacterInterval;

        // Default visuals based on style
        SetDefaultVisuals();
    }

    /// <summary>
    /// Set default visual properties based on style.
    /// </summary>
    private void SetDefaultVisuals()
    {
        switch (Style)
        {
            case ProjectileAnimStyle.Instant:
                SpawnTrail = false;
                break;

            case ProjectileAnimStyle.Bullet:
                Character = GetDirectionalBulletChar();
                CharacterSequence = null;
                SpawnTrail = true;
                TrailDensity = 0.3f;
                break;

            case ProjectileAnimStyle.Beam:
                Character = GetDirectionalBeamChar();
                CharacterSequence = null;
                SpawnTrail = false;  // Beam is the trail
                break;

            case ProjectileAnimStyle.Plasma:
                CharacterSequence = new[] { '*', 'o', 'O', 'o' };
                SpawnTrail = true;
                TrailDensity = 0.8f;
                TrailLifetime = 0.2f;
                break;

            case ProjectileAnimStyle.Lobbed:
                CharacterSequence = new[] { '*', 'o' };
                SpawnTrail = true;
                TrailDensity = 0.5f;
                break;

            case ProjectileAnimStyle.Chain:
                CharacterSequence = new[] { '*', '~', '=' };
                SpawnTrail = true;
                TrailDensity = 1.0f;
                TrailLifetime = 0.1f;
                break;
        }
    }

    /// <summary>
    /// Get directional character for bullet based on trajectory.
    /// </summary>
    private char GetDirectionalBulletChar()
    {
        var dir = End - Start;

        // Determine primary direction
        if (Mathf.Abs(dir.X) > Mathf.Abs(dir.Y) * 2)
            return '-';  // Horizontal
        if (Mathf.Abs(dir.Y) > Mathf.Abs(dir.X) * 2)
            return '|';  // Vertical
        if ((dir.X > 0 && dir.Y > 0) || (dir.X < 0 && dir.Y < 0))
            return '\\';  // Main diagonal
        return '/';  // Anti-diagonal
    }

    /// <summary>
    /// Get directional character for beam based on trajectory.
    /// </summary>
    private char GetDirectionalBeamChar()
    {
        var dir = End - Start;

        if (Mathf.Abs(dir.X) > Mathf.Abs(dir.Y) * 2)
            return '=';  // Horizontal beam
        if (Mathf.Abs(dir.Y) > Mathf.Abs(dir.X) * 2)
            return '|';  // Vertical beam
        if ((dir.X > 0 && dir.Y > 0) || (dir.X < 0 && dir.Y < 0))
            return '\\';
        return '/';
    }

    /// <summary>
    /// Update the projectile animation.
    /// </summary>
    public void Update(float delta)
    {
        Timer += delta;

        // Update character animation
        if (CharacterSequence != null && CharacterSequence.Length > 1)
        {
            _characterTimer -= delta;
            if (_characterTimer <= 0)
            {
                _characterTimer = CharacterInterval;
                _characterIndex = (_characterIndex + 1) % CharacterSequence.Length;
            }
        }

        // Spawn trail particles
        if (SpawnTrail && !IsComplete)
        {
            SpawnTrailParticle();
        }

        // Update existing trail particles
        for (int i = TrailParticles.Count - 1; i >= 0; i--)
        {
            var p = TrailParticles[i];
            p.Update(delta);
            TrailParticles[i] = p;

            if (!p.IsAlive)
            {
                TrailParticles.RemoveAt(i);
            }
        }
    }

    /// <summary>
    /// Spawn a trail particle at current position.
    /// </summary>
    private void SpawnTrailParticle()
    {
        var currentGridPos = GridPosition;

        // Only spawn if we've moved to a new tile
        if (currentGridPos == _lastTrailPos)
            return;

        // Check density
        if (GD.Randf() > TrailDensity)
        {
            _lastTrailPos = currentGridPos;
            return;
        }

        var particle = Particle.CreateFading(
            _lastTrailPos,
            GetTrailChar(),
            TrailColor.A > 0 ? TrailColor : Color * 0.6f,
            new Color(TrailColor.R, TrailColor.G, TrailColor.B, 0),
            TrailLifetime
        );
        particle.Type = ParticleType.Generic;
        particle.BlendMode = ParticleBlendMode.Behind;

        TrailParticles.Add(particle);
        _lastTrailPos = currentGridPos;
    }

    /// <summary>
    /// Get trail character based on style.
    /// </summary>
    private char GetTrailChar()
    {
        return Style switch
        {
            ProjectileAnimStyle.Bullet => '.',
            ProjectileAnimStyle.Plasma => '*',
            ProjectileAnimStyle.Chain => '~',
            ProjectileAnimStyle.Lobbed => '.',
            _ => '.'
        };
    }

    /// <summary>
    /// Get all positions along the beam line (for beam-style weapons).
    /// </summary>
    public List<Vector2I> GetBeamPositions()
    {
        var positions = new List<Vector2I>();

        int x0 = Start.X, y0 = Start.Y;
        int x1 = End.X, y1 = End.Y;

        int dx = Mathf.Abs(x1 - x0);
        int dy = Mathf.Abs(y1 - y0);
        int sx = x0 < x1 ? 1 : -1;
        int sy = y0 < y1 ? 1 : -1;
        int err = dx - dy;

        while (true)
        {
            positions.Add(new Vector2I(x0, y0));

            if (x0 == x1 && y0 == y1)
                break;

            int e2 = 2 * err;
            if (e2 > -dy)
            {
                err -= dy;
                x0 += sx;
            }
            if (e2 < dx)
            {
                err += dx;
                y0 += sy;
            }
        }

        return positions;
    }

    /// <summary>
    /// Create a projectile from weapon data.
    /// </summary>
    public static ProjectileVisual FromWeaponData(
        Vector2I start,
        Vector2I end,
        WeaponData weapon)
    {
        var style = weapon.ProjectileStyle switch
        {
            Combat.ProjectileStyle.None => ProjectileAnimStyle.Instant,
            Combat.ProjectileStyle.Bullet => ProjectileAnimStyle.Bullet,
            Combat.ProjectileStyle.Beam => ProjectileAnimStyle.Beam,
            Combat.ProjectileStyle.Arc => ProjectileAnimStyle.Chain,
            Combat.ProjectileStyle.Lobbed => ProjectileAnimStyle.Lobbed,
            Combat.ProjectileStyle.Explosion => ProjectileAnimStyle.Lobbed,
            _ => ProjectileAnimStyle.Bullet
        };

        var proj = new ProjectileVisual(start, end, style, weapon.ProjectileSpeed)
        {
            Character = weapon.ProjectileChar.Length > 0 ? weapon.ProjectileChar[0] : '*',
            Color = weapon.ProjectileColor,
            TrailColor = weapon.ProjectileColor * 0.5f
        };

        return proj;
    }
}
